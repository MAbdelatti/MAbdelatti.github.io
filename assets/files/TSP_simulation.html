<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRP Optimization Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font for a clean look */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
        }
        canvas {
            border: 2px solid #ccc;
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
        }
        .simulation-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
        }
    </style>
</head>
<body>

    <div class="simulation-container">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-6 text-center">
            VRP: Simulating the Search for the Optimal Route
        </h1>

        <div id="status" class="text-lg font-semibold text-gray-600 mb-4 h-6">Press Start to begin.</div>
        
        <canvas id="vrpCanvas" width="800" height="600"></canvas>

        <button id="startButton" class="mt-8 px-8 py-3 text-lg font-bold text-white bg-green-600 rounded-xl shadow-lg hover:bg-green-700 transition duration-300 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed">
            Start VRP Search
        </button>
    </div>

    <script>
        const canvas = document.getElementById('vrpCanvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const statusEl = document.getElementById('status');

        let isRunning = false;

        // Define the fixed nodes (customers/cities)
        const NODES = [
            { x: 100, y: 100, label: 'Depot (0)' }, // Start/End
            { x: 450, y: 50, label: 'A (1)' },
            { x: 650, y: 200, label: 'B (2)' },
            { x: 200, y: 350, label: 'C (3)' },
            { x: 750, y: 450, label: 'D (4)' },
            { x: 300, y: 500, label: 'E (5)' }
        ];

        // Define a sequence of paths to simulate the optimization process
        // The last path in the array is the "Optimal Route"
        const PATHS = [
            // Sub-optimal Path 1 (Long zig-zag)
            [0, 3, 5, 2, 4, 1, 0],
            // Sub-optimal Path 2 (Medium zig-zag)
            [0, 1, 3, 5, 4, 2, 0],
            // Sub-optimal Path 3 (Near optimal)
            [0, 1, 2, 4, 5, 3, 0], 
            // Optimal Path (Clear, efficient route - will be kept on screen)
            [0, 1, 4, 2, 5, 3, 0] 
        ];

        const ANIMATION_SPEED_MS = 1000; // Time each sub-optimal path is displayed

        function drawNodes(highlightIndex = -1) {
            // Clear canvas and draw a white background
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            NODES.forEach((node, index) => {
                const isDepot = index === 0;

                // Draw Circle
                ctx.beginPath();
                ctx.arc(node.x, node.y, isDepot ? 12 : 8, 0, 2 * Math.PI);
                
                if (isDepot) {
                    ctx.fillStyle = '#10B981'; // Green for Depot
                    ctx.strokeStyle = '#059669';
                    ctx.lineWidth = 3;
                } else {
                    ctx.fillStyle = '#3B82F6'; // Blue for Customers
                    ctx.strokeStyle = '#2563EB';
                    ctx.lineWidth = 2;
                }

                ctx.fill();
                ctx.stroke();
                
                // Draw Label
                ctx.fillStyle = '#1F2937';
                ctx.font = '14px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(node.label, node.x, node.y - (isDepot ? 15 : 10));
            });
        }

        function drawPath(path, isOptimal = false) {
            ctx.beginPath();
            
            // Set style based on whether it is the optimal path
            if (isOptimal) {
                ctx.strokeStyle = '#D97706'; // Amber for optimal
                ctx.lineWidth = 5;
                ctx.setLineDash([]); // Solid line
            } else {
                ctx.strokeStyle = '#9CA3AF'; // Gray for sub-optimal
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]); // Dashed line
            }

            // Move to the first node
            let firstNode = NODES[path[0]];
            ctx.moveTo(firstNode.x, firstNode.y);

            // Draw lines to subsequent nodes
            for (let i = 1; i < path.length; i++) {
                let nextNode = NODES[path[i]];
                ctx.lineTo(nextNode.x, nextNode.y);
            }

            ctx.stroke();
            ctx.closePath();
        }

        async function animateVRP() {
            if (isRunning) return;
            isRunning = true;
            startButton.disabled = true;

            // 1. Draw initial state
            drawNodes();
            statusEl.textContent = 'Searching for best routes...';
            await new Promise(resolve => setTimeout(resolve, 500));

            // 2. Iterate through sub-optimal paths
            for (let i = 0; i < PATHS.length; i++) {
                const path = PATHS[i];
                const isOptimal = i === PATHS.length - 1;

                // Clear canvas but keep nodes
                drawNodes(); 

                if (!isOptimal) {
                    // Draw sub-optimal path (dashed gray)
                    drawPath(path, false);
                    statusEl.textContent = `Attempt ${i + 1}/${PATHS.length - 1}: Long, non-optimal route...`;
                    await new Promise(resolve => setTimeout(resolve, ANIMATION_SPEED_MS));
                } else {
                    // Final Optimal Path (solid amber)
                    drawPath(path, true);
                    statusEl.textContent = 'Solution Found! This is the Optimal Route.';
                }
            }

            isRunning = false;
            startButton.disabled = false;
            statusEl.classList.add('text-amber-700');
        }

        // Initialize: Draw the nodes when the page loads
        drawNodes();
        
        startButton.addEventListener('click', () => {
             // Reset status color for next run
            statusEl.classList.remove('text-amber-700');
            animateVRP();
        });

    </script>
</body>
</html>
